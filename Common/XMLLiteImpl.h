/*---------------------------------------------------------------------+\
|
|	XMLLiteImpl.h  --  Implementation for XMLLite
|
|	Purpose:
|
| optional topics (delete if not used)
|	Restrictions/Warnings:
|	Formats:
|	References:
|	Notes:
|
\+---------------------------------------------------------------------*/
/*---------------------------------------------------------------------+\
|
|	Revision History:					(most recent entries first)
|
	10-Apr-2010			J.Griswold		(Reviewed by: xxxx)
		Move to "Common" folder with "Xxx::Common::" namespace
	22-Jan-2010			J.Griswold		(Reviewed by: M.Rose)
		Use the newer standalone functions ParseDecDigits,
		ParseHexDigits and ParseFloat
	21-Jan-2010			J.Griswold		(Reviewed by: M.Rose)
		Utilize the new ParseInt and ParseFloat functions
		that are available on the TCharDescriptor
	07-Dec-2009			J.Griswold		(Reviewed by: M.Rose)
		Change to using UFloat.h to identify if we are building
		with fixed-point or not
	06-Dec-2009			J.Griswold		(Reviewed by: M.Rose)
		Add support for fixed-point replacement for float
	06-Oct-2009			J.Griswold		(Reviewed by: M.Rose)
		Add HeaderRequired function that identifies whether the
		<?xml?> header is required or not.  The default should be
		required.
	30-Sep-2009			J.Griswold		(Reviewed by: M.Rose)
		Fix SpanFloat so that it does not return failure when it
		enounters non-float data.  The calling function needs to
		determine how to deal with what SpanFloat encountered.
	22-Sep-2009			J.Griswold		(Reviewed by: M.Rose)
		Change the iterator template class to take two arguments.
		The new argument identifies the type of tokenizer.
		Also handle ignoring the Byte Order Marks at the beginning
		of the file/stream.
	21-Sep-2009			J.Griswold		(Reviewed by: R.Hosea)
		Add SpanFloat function to do generic floating parsing
		Fix a problem in SpanNumber where it was referencing
		the pointer content instead of just checking the address.
	19-Sep-2009			J.Griswold		(Reviewed by: M.Rose)
		fix a problem in NumberFromFlt that caused the fraction
		part of a number to be too small.
	16-Sep-2009			J.Griswold		(Reviewed by: M.Rose)
		Resolve compiler warning generated by GCC++
	15-Sep-2009			J.Griswold		(Reviewed by: M.Rose)
		Add ProcessCallBack function
		Fix compiler warnings
	15-Sep-2009			J.Griswold		(Reviewed by: M.Rose)
		Force us to exit the parse after a call to the Error function
	14-Sep-2009			J.Griswold		(Reviewed by: R.Hosea)
		change constructor of TIterator to hopefully be compatible with
		GCC compiler.
	14-Sep-2009			J.Griswold		(Reviewed by: M.Rose)
		fix some subtle parsing rules for better conformance with
		the XML specification
	09-Sep-2009			J.Griswold		(Reviewed by: M.Rose)
		Add correct calculation of line number
		Add ErrorStreamName and ErrorToken functions
	03-Sep-2009			J.Griswold		(Reviewed by: M.Rose)
		Add support for NodeValueAsInt and NodeValueAsFloat
		Add NodeEmpty function
	26-Aug-2009			J.Griswold		(Reviewed by: M.Rose)
		Initial Revision
|
\+---------------------------------------------------------------------*/
#ifndef _H_XMLLiteImpl
#define _H_XMLLiteImpl
#pragma once
/*---------------------------------------------------------------------+\
|																		|
|	Include Files														|
|																		|
\+---------------------------------------------------------------------*/
#include <stdio.h>
#include <ctype.h>
#include <math.h>

#include "XMLLite.h"
#include "TCharDescriptor.h"

#include "LogFile.h"
#include "UPlatform.h"
#include "UPlatformString.h"

#include "UDeclCommon.h"

namespace Yogi { namespace XMLLite {

/*---------------------------------------------------------------------+\
|																		|
|	Defines																|
|																		|
\+---------------------------------------------------------------------*/
/*---------------------------------------------------------------------+\
|																		|
|	Type Definitions													|
|																		|
\+---------------------------------------------------------------------*/
/*---------------------------------------------------------------------+\
|																		|
|	Class Definitions													|
|																		|
\+---------------------------------------------------------------------*/

/*---------------------------------------------------------------------+\
|	template TTokenizer													|
\+---------------------------------------------------------------------*/

template < class T >
class TTokenizer : public VTokenizer<T>
{
//	class lifecycle  ----------------------------------------------------
public:
					TTokenizer();
	virtual			~TTokenizer();

public:
//	public types  -------------------------------------------------------

//	public functions  ---------------------------------------------------


protected:
//	protected types  ----------------------------------------------------

	// we create this typedef to get around a limitation on g++
	typedef Yogi::Core::TCharDescriptor<T>  TCD;

	typedef struct AttributeInfo
	{
		Yogi::Core::TCharDescriptor<T>	tName;
		Yogi::Core::TCharDescriptor<T>	tValue;
	} AttributeInfo;

//	protected functions  ------------------------------------------------

	void				IdentifyTargetFormat( void );
	void				Reset( void );
	void				PushNode( Yogi::Core::TCharDescriptor<T>& r );
	Yogi::Core::TCharDescriptor<T>	PopNode( void );


	bool				ReadFromCallBack( void );

	bool				IsBlank( T c );
	long				SpanByteOrderMarks( T* s, T* sEnd = 0 );
	long				SpanBlanks( const T* s, const T* sEnd = 0 );
	long				SpanCharEntity( T* s, T* sEnd = 0, T* nChar = 0 );
	long				SpanName( T* s, T* sEnd = 0 );
	long				SpanEqual( T* s, T* sEnd = 0 );
	long				SpanQuote( T* s, T* sEnd = 0 );
	long				SpanNumber( const T* s, const T* sEnd = 0, long* pNumber = 0 );
	long				SpanFloat( const T* s, const T* sEnd = 0, GFLOAT* pNumber = 0 );

	T					SpecialCharacters( const T* s, long& n );
	long				NumberFromHex( const T* s, size_t n );
	long				NumberFromDec( const T* s, size_t n );
	GFLOAT				NumberFromFlt( const T* s, size_t n );

	long				ParseAttributes( T* s, T* sEnd = 0 );
	long				ParseOneAttribute( T* s );
	Yogi::Core::TCharDescriptor<T>	ParseAttributeValue( T* s, size_t n );

	bool				ParseNode( void );

	bool				ParseHeader( void );
	bool				ParseElement( void );
	bool				ParseEndElement( void );
	bool				ParseElementValue( const Yogi::Core::TCharDescriptor<T>& rName );
	bool				ParseElementValueEnd( const Yogi::Core::TCharDescriptor<T>& rName );
	bool				ParseCData( void );
	bool				ParseText( void );
	bool				ParseEntity( void );
	bool				ParseProcessingInstruction( void );
	bool				ParseComment( void );
	bool				ParseDoctype( void );
	bool				ParseNotation( void );


//	protected data  -----------------------------------------------------

	bool							m_bHeaderRequired;	// allow <?xml?> to be optional
	XMLLite::VReadCallBack*			m_pReadCallBack;
	Yogi::Core::TArray<T>			m_sStream;
	Yogi::Core::TArray<char>		m_sStreamName;
	Yogi::Core::TCharDescriptor<T>	m_tFullStream;

	Yogi::Core::TArray<TCD>			m_aNodeStack;
	int								m_nNodeStack;	// size of stack
	Yogi::Core::TArray<AttributeInfo>	m_aAttributes;

	ENODETYPE						m_eNodeType;
	Yogi::Core::TCharDescriptor<T>	m_tNodeName;	// name of current element
	Yogi::Core::TCharDescriptor<T>	m_tNodeValue;

	T*								m_pCurrentPosition;
	T*								m_pEndPosition;		// actually one past the end

	index_t							m_nErrorLine;
	Yogi::Core::TCharDescriptor<T>	m_tErrorToken;
	Yogi::Core::TArray<char>		m_sErrorString;

	ETEXT_FORMAT					m_eTargetFormat;
	ETEXT_FORMAT					m_eSourceFormat;

private:
//	private functions  --------------------------------------------------

//	private data  -------------------------------------------------------

//============================== Overrides ==============================
	//	VTokenizer
public:

	virtual bool		HeaderRequired( bool bRequired );

	virtual bool		ProcessCallBack( XMLLite::VReadCallBack* pCallBack );

	virtual bool		Read( void );

	virtual
	void					Error( const char* s );
	virtual
	index_t					ErrorLineNumber( void );
	virtual
	Yogi::Core::TCharDescriptor<char>	ErrorString( void );
	virtual
	Yogi::Core::TCharDescriptor<T>		ErrorToken( void );
	virtual
	Yogi::Core::TCharDescriptor<char>	ErrorStreamName( void );


	virtual int			NestDepth( void );

	virtual ENODETYPE			NodeType( void );
	virtual Yogi::Core::TCharDescriptor<T>	NodeName( void );
	virtual bool				NodeEmpty( void );
	virtual Yogi::Core::TCharDescriptor<T>	NodeValue( void );

	virtual long				NodeValueAsInt( void );
	virtual GFLOAT				NodeValueAsFloat( void );

	virtual int					AttributeCount( void );
	virtual Yogi::Core::TCharDescriptor<T>	AttributeName( int idx );
	virtual Yogi::Core::TCharDescriptor<T>	AttributeValue( int idx );
	virtual Yogi::Core::TCharDescriptor<T>	AttributeValue( const T* sName );

	virtual long				AttributeValueAsInt( const char* sName );
	virtual long				AttributeValueAsInt( int idx );
	virtual GFLOAT				AttributeValueAsFloat( const char* sName );
	virtual GFLOAT				AttributeValueAsFloat( int idx );

};



/*---------------------------------------------------------------------+\
|	template TIterator													|
\+---------------------------------------------------------------------*/

template < class T, class TTok >
class TIterator : public VIterator<T,TTok>
{
//	class lifecycle  ----------------------------------------------------
public:
				TIterator( TTok* pTokenizer );
				TIterator( VIterator<T,TTok>* p );
				TIterator( VIterator<T,TTok>& r );
	virtual		~TIterator();

public:
//	public types  -------------------------------------------------------

//	public functions  ---------------------------------------------------



protected:
//	protected types  ----------------------------------------------------

//	protected functions  ------------------------------------------------

//	protected data  -----------------------------------------------------

	TTok*		m_pTokenizer;
	int			m_nNestDepth;

//============================== Overrides ==============================
	//	VTokenizer
public:
	virtual bool				NextChild( void );

	virtual ENODETYPE			NodeType( void );
	virtual Yogi::Core::TCharDescriptor<T>	NodeName( void );
	virtual bool				NodeEmpty( void );
	virtual Yogi::Core::TCharDescriptor<T>	NodeValue( void );

	virtual long				NodeValueAsInt( void );
	virtual GFLOAT				NodeValueAsFloat( void );

	virtual int					AttributeCount( void );
	virtual Yogi::Core::TCharDescriptor<T>	AttributeName( int idx );
	virtual Yogi::Core::TCharDescriptor<T>	AttributeValue( int idx );
	virtual Yogi::Core::TCharDescriptor<T>	AttributeValue( const char* sName );

	virtual long				AttributeValueAsInt( const char* sName );
	virtual long				AttributeValueAsInt( int idx );
	virtual GFLOAT				AttributeValueAsFloat( const char* sName );
	virtual GFLOAT				AttributeValueAsFloat( int idx );

	virtual void				Error( const char* sMessage );

	virtual TTok*				Tokenizer( void );
};





/*---------------------------------------------------------------------+\
|	CReadFile															|
\+---------------------------------------------------------------------*/

class DECL_CLASS CReadFile : public XMLLite::VReadCallBack
{
public:
			CReadFile();
	virtual ~CReadFile();

public:
	bool	Open( const char* sFilename );
	bool	Close( void );


protected:

	void	CalculateSize( void );

	FILE*	m_pFile;
	size_t	m_nSize;
	char	m_sName[512];



//============================== Overrides ==============================
	//	XMLLite::VReadCallBack
public:
	virtual
	size_t	Read					// RTN:	returns number of bytes actually read
			(
			void*			pBuffer,		// OUT: buffer to receive data
			size_t			nBytesToRead,	// IN:	number of bytes to read
			ETEXT_FORMAT	eFmt			// IN:	target format
			);

	/*
		Gets the size of the file (steam)
	*/
	virtual
	size_t	GetSize		// RTN:	return file (stream) size in bytes
			(
			void
			);

	virtual
	size_t	GetName					// RTN:	string length of name
			(
			char*			sTarget,	// OUT:	buffer to receive name
			size_t			nSizeTarget	// IN:	size of target
			);
};





/*---------------------------------------------------------------------+\
|																		|
|	External Variables													|
|																		|
\+---------------------------------------------------------------------*/
/*=====================================================================+\
||																		|
||	Function Prototypes													|
||																		|
\+=====================================================================*/
/*=====================================================================+\
||																		|
||	Template Functions													|
||																		|
\+=====================================================================*/


/*=====================================================================+\
||	TIterator Functions													|
\+=====================================================================*/

/*---------------------------------------------------------------------+\

 * TIterator - Constructor

\+---------------------------------------------------------------------*/
template < class T, class TTok >
TIterator<T,TTok>::TIterator
		(
		TTok*	p
		)
		: m_pTokenizer( p ),
		m_nNestDepth( 0 )
{
	m_nNestDepth = p->NestDepth();
}

/*---------------------------------------------------------------------+\

 * TIterator - Constructor

\+---------------------------------------------------------------------*/
template < class T, class TTok >
TIterator<T,TTok>::TIterator
		(
		VIterator<T,TTok>*	p
		)
		: m_pTokenizer( p->Tokenizer() ),
		m_nNestDepth( 0 )
{
	m_nNestDepth = p->Tokenizer()->NestDepth();
}

/*---------------------------------------------------------------------+\

 * TIterator - Constructor

\+---------------------------------------------------------------------*/
template < class T, class TTok >
TIterator<T,TTok>::TIterator
		(
		VIterator<T,TTok>&	r
		)
		: m_pTokenizer( r.Tokenizer() ),
		m_nNestDepth( 0 )
{
	m_nNestDepth = r.Tokenizer()->NestDepth();
}

/*---------------------------------------------------------------------+\

 * ~TIterator - Destructor

\+---------------------------------------------------------------------*/
template < class T, class TTok >
TIterator<T,TTok>::~TIterator
		(
		void
		)
{
}


/*---------------------------------------------------------------------+\

 * NextChild -

\+---------------------------------------------------------------------*/
template < class T, class TTok >
bool	TIterator<T,TTok>::NextChild
		(
		void
		)
{
	bool	bResult = false;
	int		nNest = m_pTokenizer->NestDepth();
	if ( m_nNestDepth <= nNest )
	{
		bResult = m_pTokenizer->Read();
		if ( bResult )
		{
			if ( m_pTokenizer->NestDepth() < m_nNestDepth )
				bResult = false;
		}
	}
	return bResult;
}


/*---------------------------------------------------------------------+\

 * NodeType -

\+---------------------------------------------------------------------*/
template < class T, class TTok >
inline
ENODETYPE
		TIterator<T,TTok>::NodeType
		(
		void
		)
{
	return m_pTokenizer->NodeType();
}

/*---------------------------------------------------------------------+\

 * NodeName -

\+---------------------------------------------------------------------*/
template < class T, class TTok >
inline
Yogi::Core::TCharDescriptor<T>
		TIterator<T,TTok>::NodeName
		(
		void
		)
{
	return m_pTokenizer->NodeName();
}


/*---------------------------------------------------------------------+\

 * NodeEmpty -

\+---------------------------------------------------------------------*/
template < class T, class TTok >
inline
bool	TIterator<T,TTok>::NodeEmpty
		(
		void
		)
{
	return m_pTokenizer->NodeEmpty();
}


/*---------------------------------------------------------------------+\

 * NodeValue -

\+---------------------------------------------------------------------*/
template < class T, class TTok >
inline
Yogi::Core::TCharDescriptor<T>
		TIterator<T,TTok>::NodeValue
		(
		void
		)
{
	return m_pTokenizer->NodeValue();
}


/*---------------------------------------------------------------------+\

 * NodeValueAsInt -

\+---------------------------------------------------------------------*/
template < class T, class TTok >
inline
long	TIterator<T,TTok>::NodeValueAsInt
		(
		void
		)
{
	return m_pTokenizer->NodeValueAsInt();
}


/*---------------------------------------------------------------------+\

 * NodeValueAsFloat -

\+---------------------------------------------------------------------*/
template < class T, class TTok >
inline
GFLOAT
		TIterator<T,TTok>::NodeValueAsFloat
		(
		void
		)
{
	return m_pTokenizer->NodeValueAsFloat();
}


/*---------------------------------------------------------------------+\

 * AttributeCount -

\+---------------------------------------------------------------------*/
template < class T, class TTok >
inline
int		TIterator<T,TTok>::AttributeCount
		(
		void
		)
{
	return m_pTokenizer->AttributeCount();
}


/*---------------------------------------------------------------------+\

 * AttributeName -

\+---------------------------------------------------------------------*/
template < class T, class TTok >
inline
Yogi::Core::TCharDescriptor<T>
		TIterator<T,TTok>::AttributeName
		(
		int	idx
		)
{
	return m_pTokenizer->AttributeName( idx );
}


/*---------------------------------------------------------------------+\

 * AttributeValue -

\+---------------------------------------------------------------------*/
template < class T, class TTok >
inline
Yogi::Core::TCharDescriptor<T>
		TIterator<T,TTok>::AttributeValue
		(
		int	idx
		)
{
	return m_pTokenizer->AttributeValue( idx );
}


/*---------------------------------------------------------------------+\

 * AttributeValue -

\+---------------------------------------------------------------------*/
template < class T, class TTok >
inline
Yogi::Core::TCharDescriptor<T>
		TIterator<T,TTok>::AttributeValue
		(
		const char* sName
		)
{
	return m_pTokenizer->AttributeValue( sName );
}


/*---------------------------------------------------------------------+\

 * AttributeValueAsInt -

\+---------------------------------------------------------------------*/
template < class T, class TTok >
inline
long	TIterator<T,TTok>::AttributeValueAsInt
		(
		int	idx
		)
{
	return m_pTokenizer->AttributeValueAsInt( idx );
}


/*---------------------------------------------------------------------+\

 * AttributeValueAsInt -

\+---------------------------------------------------------------------*/
template < class T, class TTok >
inline
long	TIterator<T,TTok>::AttributeValueAsInt
		(
		const char* sName
		)
{
	return m_pTokenizer->AttributeValueAsInt( sName );
}


/*---------------------------------------------------------------------+\

 * AttributeValueAsFloat -

\+---------------------------------------------------------------------*/
template < class T, class TTok >
inline
GFLOAT
		TIterator<T,TTok>::AttributeValueAsFloat
		(
		int	idx
		)
{
	return m_pTokenizer->AttributeValueAsFloat( idx );
}


/*---------------------------------------------------------------------+\

 * AttributeValueAsFloat -

\+---------------------------------------------------------------------*/
template < class T, class TTok >
inline
GFLOAT
		TIterator<T,TTok>::AttributeValueAsFloat
		(
		const char* sName
		)
{
	return m_pTokenizer->AttributeValueAsFloat( sName );
}

/*---------------------------------------------------------------------+\

 * Error - identify error condition

\+---------------------------------------------------------------------*/
template < class T, class TTok >
inline
void	TIterator<T,TTok>::Error
		(
		const char*	sMessage
		)
{
	m_pTokenizer->Error( sMessage );
}


/*---------------------------------------------------------------------+\

 * Tokenizer - get tokenizer pointer

\+---------------------------------------------------------------------*/
template < class T, class TTok >
inline
TTok*	TIterator<T,TTok>::Tokenizer
		(
		void
		)
{
	return m_pTokenizer;
}




/*=====================================================================+\
||	Tokenizer Functions													|
\+=====================================================================*/


/*---------------------------------------------------------------------+\

 * TTokenizer - Constructor

\+---------------------------------------------------------------------*/
template < class T >
TTokenizer<T>::TTokenizer
		(
		void
		)
		: m_bHeaderRequired( true )
		, m_pReadCallBack( 0 )
		, m_sStream()
		, m_sStreamName()
		, m_tFullStream()
		, m_aNodeStack()
		, m_nNodeStack( 0 )
		, m_aAttributes()
		, m_eNodeType( NODE_NONE )
		, m_tNodeName()
		, m_tNodeValue()
		, m_pCurrentPosition( 0 )
		, m_pEndPosition( 0 )
		, m_nErrorLine( 0 )
		, m_tErrorToken()
		, m_sErrorString()
		, m_eTargetFormat( ETF_ASCII )
		, m_eSourceFormat( ETF_ASCII )
{
	IdentifyTargetFormat();
	Reset();
}




/*---------------------------------------------------------------------+\

 * ~TTokenizer - Destructor

\+---------------------------------------------------------------------*/
template < class T >
TTokenizer<T>::~TTokenizer
		(
		void
		)
{
}


/*---------------------------------------------------------------------+\

 * IdentifyTargetFormat -

\+---------------------------------------------------------------------*/
template < class T >
void	TTokenizer<T>::IdentifyTargetFormat
		(
		void
		)
{
	switch ( sizeof(T) )
	{
	case 1:
		m_eTargetFormat = ETF_ASCII;	// assume ASCII but look at the header later
		break;
	case 2:
		m_eTargetFormat = ETF_UTF16;
		break;
	default:
		m_eTargetFormat = ETF_ASCII;
		break;
	}
}


/*---------------------------------------------------------------------+\

 * Reset -

\+---------------------------------------------------------------------*/
template < class T >
void	TTokenizer<T>::Reset
		(
		void
		)
{
	m_sStream.Truncate();
	m_tFullStream = Yogi::Core::TCharDescriptor<T>();
	m_sStreamName[0] = 0;
	m_sStreamName.Truncate();

	m_aNodeStack.Truncate();
	m_nNodeStack = 0;

	m_aAttributes.Truncate();

	m_eNodeType = NODE_NONE;
	m_tNodeName = Yogi::Core::TCharDescriptor<T>();
	m_tNodeValue = Yogi::Core::TCharDescriptor<T>();

	m_pCurrentPosition = 0;

	m_nErrorLine = 0;
	m_tErrorToken = Yogi::Core::TCharDescriptor<T>();
	m_sErrorString.Truncate();
}


/*---------------------------------------------------------------------+\

 * PushNode -

\+---------------------------------------------------------------------*/
template < class T >
void	TTokenizer<T>::PushNode
		(
		Yogi::Core::TCharDescriptor<T>&	r
		)
{
	Yogi::Core::TCharDescriptor<T>*	p = m_aNodeStack.PointItem( m_nNodeStack );
	if ( p )
	{
		m_nNodeStack++;
		(*p) = r;
	}
}


/*---------------------------------------------------------------------+\

 * PopNode -

\+---------------------------------------------------------------------*/
template < class T >
Yogi::Core::TCharDescriptor<T>
		TTokenizer<T>::PopNode
		(
		void
		)
{
	if ( 0 < m_nNodeStack )
		--m_nNodeStack;

    Yogi::Core::TCharDescriptor<T>* p = m_aNodeStack.PointItem( m_nNodeStack );
    if ( p )
	    return *p;
    else
        return Yogi::Core::TCharDescriptor<T>();
}


/*---------------------------------------------------------------------+\

 * ReadFromCallBack -

\+---------------------------------------------------------------------*/
template < class T >
bool	TTokenizer<T>::ReadFromCallBack
		(
		void
		)
{
	size_t	nSize = m_pReadCallBack->GetSize();

	m_sStream.Truncate();
	m_sStream.AdjustUsed( nSize );
	size_t	n = m_pReadCallBack->GetName( m_sStreamName.PointArray(), 0 );
	m_sStreamName.AdjustUsed( n + 1 );
	m_pReadCallBack->GetName( m_sStreamName.PointArray(), n+1 );

	T*	p = m_sStream.PointArray();
	nSize = m_pReadCallBack->Read( p, nSize, m_eTargetFormat );
	m_pCurrentPosition = p;
	m_pEndPosition = p + nSize;
	m_tFullStream = Yogi::Core::TCharDescriptor<T>( p, nSize );
	return true;
}


/*---------------------------------------------------------------------+\

 * IsBlank -

\+---------------------------------------------------------------------*/
template < class T >
inline
bool	TTokenizer<T>::IsBlank
		(
		T	c
		)
{
	// please note that NULL is considered a blank character
	return  c < 0x0021;			// standard space, CR, LF, TAB, etc

//			||	0x00A0 == wc		// non-breaking space
//			||	(0x2002 <= wc && wc <= 0x200C);	// unicode spacers
}


/*---------------------------------------------------------------------+\

 * SpanByteOrderMarks -

\+---------------------------------------------------------------------*/
template < class T >
long	TTokenizer<T>::SpanByteOrderMarks
		(
		T*	s,
		T*	sEnd
		)
{
	const T*	sStart = s;
	if ( ! sEnd )
		sEnd = m_pEndPosition;

	if ( static_cast<T>(0x00EFu) == *s
		&&  static_cast<T>(0x00BBu) == *(s+1)
		&&	static_cast<T>(0x00BFu) == *(s+2) )
		s += 3;
	else if ( static_cast<T>(0x00FFu) == *s
		&&	static_cast<T>(0x00FEu) == *(s+1) )
		s += 2;
	else if ( static_cast<T>(0x00FEu) == *s
		&&	static_cast<T>(0x00FFu) == *(s+1) )
		s += 2;

	return long(s - sStart);
}


/*---------------------------------------------------------------------+\

 * SpanBlanks -

\+---------------------------------------------------------------------*/
template < class T >
long	TTokenizer<T>::SpanBlanks
		(
		const T*	s,
		const T*	sEnd
		)
{
	const T*	sStart = s;
	if ( ! sEnd )
		sEnd = m_pEndPosition;

	while ( s < sEnd )
	{
		if ( ! IsBlank( *s ) )
			break;
		++s;
	}
	return long(s - sStart);
}


/*---------------------------------------------------------------------+\

 * SpanEntity -

\+---------------------------------------------------------------------*/
template < class T >
long	TTokenizer<T>::SpanCharEntity
		(
		T*	s,
		T*	sEnd,	// =0
		T*	pChar	// =0
		)
{
	T*		sStart = s;
	T		nChar = 0;
	if ( ! sEnd )
		sEnd = m_pEndPosition;

	if ( '&' == *s )
	{
		++s;
		T*	sTemp = s;

		while ( sTemp < sEnd  &&  ';' != *sTemp )
			++sTemp;

		if ( ';' == *sTemp )
		{
			if ( '#' == *s )
			{
				long	n;
				long	i;
				++s;
				i = SpanNumber( s, sTemp, &n );
				if ( i == sTemp - s )
				{
					nChar = static_cast<T>(n);
					s = sTemp + 1;
				}
				else
				{
					nChar = 0;
				}
			}
			else
			{
				s = sTemp + 1;
				Yogi::Core::TCharDescriptor<T>	tEntity( s, sTemp - s );
				if ( tEntity == "apos" )
					nChar = '\'';
				else if ( tEntity == "amp" )
					nChar = '&';
				else if ( tEntity == "gt" )
					nChar = '>';
				else if ( tEntity == "lt" )
					nChar = '<';
				else if ( tEntity == "quot" )
					nChar = '"';
				else
					nChar = 0;
			}
		}
		else
		{
			s = sStart;
		}

	}
	if ( 0 == nChar )
		s = sStart;
	if ( pChar )
		*pChar = nChar;

	return long(s - sStart);
}


/*---------------------------------------------------------------------+\

 * SpanQuote -

\+---------------------------------------------------------------------*/
template < class T >
long	TTokenizer<T>::SpanQuote
		(
		T*	s,
		T*	sEnd
		)
{
	long	nResult = 0;
	T*		sStart = s;
	if ( ! sEnd )
		sEnd = m_pEndPosition;


	if ( '"' == *s  ||  '\'' == *s )
	{
		T	cQ = *s;
		//T	cOther = ('"' == *s) ? '\'' : '"';

		++s;

		while ( s < sEnd )
		{
			if ( cQ == *s )
			{
				nResult = long(s - sStart + 1);
				break;
			}
			else if ( '>' == *s  ||  '<' == *s )
			{
				break;
			}
			++s;
		}
	}
	return nResult;
}


/*---------------------------------------------------------------------+\

 * SpanNumber -

\+---------------------------------------------------------------------*/
template < class T >
long	TTokenizer<T>::SpanNumber
		(
		const T*	s,
		const T*	sEnd,
		long*		pNumber
		)
{
	size_t	nResult = 0;
	long	nValue = 0;
	if ( ! sEnd )
		sEnd = m_pEndPosition;

	nValue = Yogi::Core::ParseIntT( s, (size_t)(sEnd - s), &nResult );

	if ( pNumber )
		*pNumber = nValue;

	return (long)nResult;
}



/*---------------------------------------------------------------------+\

 * SpanFloat -

\+---------------------------------------------------------------------*/
template < class T >
long	TTokenizer<T>::SpanFloat
		(
		const T*	s,
		const T*	sEnd,
		GFLOAT*		pNumber
		)
{
	size_t	nResult = 0;
	if ( ! sEnd )
		sEnd = m_pEndPosition;

	GFLOAT	fValue;

	fValue = Yogi::Core::ParseFloatT( s, (size_t)(sEnd - s), &nResult );

	if ( pNumber )
		*pNumber = fValue;

	return (long)nResult;
}



/*---------------------------------------------------------------------+\

 * SpanEqual - handle equals sign

\+---------------------------------------------------------------------*/
template < class T >
inline
long	TTokenizer<T>::SpanEqual
		(
		T*	s,
		T*	sEnd
		)
{
	long	nResult = 0;
	T*		sStart = s;
	if ( ! sEnd )
		sEnd = m_pEndPosition;

	do	// Sequence
	{
		s += SpanBlanks( s, sEnd );

		if ( '=' != *s )
			break;
		++s;

		s += SpanBlanks( s, sEnd );

		nResult = long(s - sStart);
	} sequence;	// End Sequence
	return nResult;
}


/*---------------------------------------------------------------------+\

 * SpecialCharacters - translate special characters

\+---------------------------------------------------------------------*/
template < class T >
T		TTokenizer<T>::SpecialCharacters
		(
		const T*	s,
		long&		n
		)
{
	T			c = 0;
	const T*	sStart = s;

	n = 0;
	if ( '&' == *s )
	{
		// &#x0000;
		bool		bFound = false;
		const T*	sEnd = s + 8;
		while ( s < sEnd )
		{
			if ( ';' == *s )
			{
				bFound = true;
				++s;
				break;
			}
			++s;
		}
		if ( bFound )
		{
			if ( '#' == *(sStart+1) )
			{
				if ( 'x' == *(sStart+2) )
					c = (T)NumberFromHex( sStart+3, (size_t)(s-sStart-3) );
				else
					c = (T)NumberFromDec( sStart+2, (size_t)(s-sStart-2) );
			}
			else
			{
				Yogi::Core::TCharDescriptor<T>	special( (T*)sStart, (size_t)(s-sStart) );
				if ( special == "&amp;" )
					c = '&';
				else if ( special == "&lt;" )
					c = '<';
				else if ( special == "&gt;" )
					c = '>';
				else if ( special == "&apos;" )
					c = '\'';
				else if ( special == "&quot;" )
					c = '"';
			}
			if ( c )
				n = long(s - sStart);
		}
	}
	return c;
}

/*---------------------------------------------------------------------+\

 * NumberFromDec -

\+---------------------------------------------------------------------*/
template < class T >
long	TTokenizer<T>::NumberFromDec
		(
		const T*	s,
		size_t		n
		)
{
	long		nValue = 0;
	const T*	sEnd = s + n;
	long		nUsed = SpanNumber( s, sEnd, &nValue );
	if ( (size_t)nUsed == n )
		return nValue;
	else
		return 0;
}


/*---------------------------------------------------------------------+\

 * NumberFromHex -

\+---------------------------------------------------------------------*/
template < class T >
long	TTokenizer<T>::NumberFromHex
		(
		const T*	s,
		size_t		n
		)
{
	return Yogi::Core::ParseHexDigitsT( s, n );
}


/*---------------------------------------------------------------------+\

 * NumberFromFlt -

\+---------------------------------------------------------------------*/
template < class T >
GFLOAT
		TTokenizer<T>::NumberFromFlt
		(
		const T*	s,
		size_t		n
		)
{
	return Yogi::Core::ParseFloatT( s, n );
}


/*---------------------------------------------------------------------+\

 * SpanName -

\+---------------------------------------------------------------------*/
template < class T >
long	TTokenizer<T>::SpanName
		(
		T*	s,
		T*	sEnd
		)
{
	T*	sStart = s;
	T	c;

	if ( ! sEnd )
		sEnd = m_pEndPosition;

	while ( s < sEnd )
	{
		c = *s;
		if ( IsBlank( c )
			||  '/' == c  ||  '?' == c
			||	'<' == c  ||  '>' == c
			||  '=' == c
			)
			break;
		++s;
	}
	return long(s - sStart);
}


/*---------------------------------------------------------------------+\

 * ParseNode -

\+---------------------------------------------------------------------*/
template < class T >
bool	TTokenizer<T>::ParseNode
		(
		void
		)
{
	bool	bResult = false;
	T*		s = m_pCurrentPosition;
//	T		c = 0;

	s += SpanBlanks( s );
	m_pCurrentPosition = s;

//	if ( '<' == *s )
//	{
//		c = *(s+1);
//	}

	if ( NODE_NONE == m_eNodeType )
	{
		s += SpanByteOrderMarks( s );
		m_pCurrentPosition = s;

		bResult = ParseHeader();
		if ( ! bResult )
		{
			if ( ! m_bHeaderRequired )
			{
				m_eNodeType = NODE_UNKNOWN;
				bResult = true;
			}
		}
	}
	else
	{
		if ( 0 < m_nNodeStack )
		{
			bResult = ParseEndElement();
		}
		else
		{
			bResult = ParseProcessingInstruction();
			if ( ! bResult )
			{
				bResult = ParseNotation();
			}
		}
		if ( ! bResult )
		{
			bResult = ParseElement();
			if ( ! bResult )
			{
				bResult = ParseComment();
			}
		}
	}
	return bResult;
}


/*---------------------------------------------------------------------+\

 * ParseAttributes -

\+---------------------------------------------------------------------*/
template < class T >
long	TTokenizer<T>::ParseAttributes
		(
		T*	sStart,
		T*	sEnd
		)
{
	long	n;
	T*		s = sStart;
	if ( ! sEnd )
		sEnd = m_pEndPosition;

	m_aAttributes.Truncate();

	while ( s < sEnd )
	{
		s += SpanBlanks( s, sEnd );
		if ( '?' == *s )
			break;
		if ( '/' == *s )
			break;
		if ( '>' == *s )
			break;
		n = ParseOneAttribute( s );
		s += 0 < n ? n : 1;
	}

	return long(s - sStart);
}


/*---------------------------------------------------------------------+\

 * ParseOneAttribute -

\+---------------------------------------------------------------------*/
template < class T >
long	TTokenizer<T>::ParseOneAttribute
		(
		T*	sStart
		)
{
	long	nResult = 0;
	T*		s = sStart;
	long	n;
	Yogi::Core::TCharDescriptor<T>	tName;
	Yogi::Core::TCharDescriptor<T>	tValue;

	do	// sequence
	{
		n = SpanBlanks( s );
		s += n;

		n = SpanName( s );
		if ( 0 == n )
			break;

		tName = Yogi::Core::TCharDescriptor<T>( s, (size_t)n );
		s += n;

		n = SpanEqual( s );
		if ( n < 1 )
			break;
		s += n;

		n = SpanQuote( s );
		if ( n < 2 )
			break;

		tValue = ParseAttributeValue( s, (size_t)n );
		s += n;

		AttributeInfo*	pInfo = m_aAttributes.AppendArray();
		if ( ! pInfo )
			break;

		pInfo->tName = tName;
		pInfo->tValue = tValue;

		nResult = long(s - sStart);

	} sequence;	// end sequence

	return nResult;
}


/*---------------------------------------------------------------------+\

 * ParseAttributeValue -

\+---------------------------------------------------------------------*/
template < class T >
Yogi::Core::TCharDescriptor<T>
		TTokenizer<T>::ParseAttributeValue
		(
		T*		s,
		size_t	n
		)
{
	Yogi::Core::TCharDescriptor<T>	tResult;
	T*		sStart = s;
	T*		sEnd = s + n - 1;	// back-off one because of closing quote
	if ( '"' == *s  ||  '\'' == *s )
	{
		//T	cQ = *s;
		//T	cOther = ('"' == *s) ? '\'' : '"';

		++s;
		sStart = s;
		T*		st = s;
		T		c;
		long	j;

		while ( s < sEnd )
		{
			if ( '&' == *s )
			{
				c = SpecialCharacters( s, j );
				if ( c )
				{
					*st++ = c;
					s += j;
				}
				else
				{
					*st++ = *s++;
				}
			}
			else
			{
				*st++ = *s++;
			}
		}
		n = (size_t)(st - sStart);
	}
	return Yogi::Core::TCharDescriptor<T>( sStart, n );
}



/*---------------------------------------------------------------------+\

 * ParseHeader -

\+---------------------------------------------------------------------*/
template < class T >
bool	TTokenizer<T>::ParseHeader
		(
		void
		)
{
	bool	bResult = false;
	long	n;
	T*		s = m_pCurrentPosition;
	T*		sXML;

	do	// sequence
	{
		//s += SpanByteOrderMarks( s );

		s += SpanBlanks( s );

		if ( '<' != *s )
			break;
		++s;

		if ( '?' != *s )
			break;
		++s;


		if ( Yogi::Core::TCharDescriptor<T>( s, 3 ) != "xml" )
			break;
		sXML = s;
		s += 3;

		s += SpanBlanks( s );

		n = ParseAttributes( s );
		s += n;

		s += SpanBlanks( s );

		if ( '?' != *s )
			break;
		++s;

		if ( '>' != *s )
			break;
		++s;

		m_tNodeName = Yogi::Core::TCharDescriptor<T>( sXML, 3 );
		m_tNodeValue = Yogi::Core::TCharDescriptor<T>();
		m_pCurrentPosition = s;
		m_eNodeType = NODE_HEADER;

		bResult = true;


	} sequence;	// end sequence

	return bResult;
}


/*---------------------------------------------------------------------+\

 * ParseElement -

\+---------------------------------------------------------------------*/
template < class T >
bool	TTokenizer<T>::ParseElement
		(
		void
		)
{
	bool	bResult = false;
	long	n;
	T*		s = m_pCurrentPosition;

	do	// sequence
	{
		if ( '<' != *s )
			break;
		++s;

		//s += SpanBlanks( s );

		if ( '!' == *s  ||  '?' == *s  ||  '/' == *s )
			break;

		n = SpanName( s );
		if ( n < 1 )
			break;

		Yogi::Core::TCharDescriptor<T>	tNodeName( s, (size_t)n );
		s += n;

		s += SpanBlanks( s );

		n = ParseAttributes( s );
		s += n;

		s += SpanBlanks( s );

		bool	bBegin = true;
		if ( '/' == *s )
		{
			bBegin = false;
			++s;
		}

		//s += SpanBlanks( s );

		if ( '>' != *s )
			break;
		++s;

		m_tNodeName = tNodeName;
		m_tNodeValue = Yogi::Core::TCharDescriptor<T>();
		m_pCurrentPosition = s;
		if ( bBegin )
		{
			if ( ParseElementValue( tNodeName ) )
			{
				m_eNodeType = NODE_ELEMENT;
			}
			else
			{
				Yogi::Core::TCharDescriptor<T>*	p = m_aNodeStack.PointItem( m_nNodeStack );
				*p = tNodeName;
				++m_nNodeStack;
				m_eNodeType = NODE_ELEMENT_BEGIN;
			}
		}
		else
		{
			m_eNodeType = NODE_ELEMENT;
		}

		bResult = true;

	} sequence;	// end sequence

	return bResult;
}


/*---------------------------------------------------------------------+\

 * ParseEndElement -

\+---------------------------------------------------------------------*/
template < class T >
bool	TTokenizer<T>::ParseEndElement
		(
		void
		)
{
	bool	bResult = false;
	long	n;
	T*		s = m_pCurrentPosition;

	do	// sequence
	{
		if ( '<' != *s )
			break;
		++s;

		//s += SpanBlanks( s );

		if ( '/' != *s )
			break;
		++s;

		s += SpanBlanks( s );

		n = SpanName( s );
		if ( n < 1 )
			break;

		Yogi::Core::TCharDescriptor<T>	tNodeName( s, (size_t)n );
		s += n;

		s += SpanBlanks( s );

		if ( '>' != *s )
			break;
		++s;

		n = m_nNodeStack - 1;
		Yogi::Core::TCharDescriptor<T>*	p = m_aNodeStack.PointArray( n );
		if ( tNodeName != *p )
		{
			Error( "Unbalanced tag" );
			m_tErrorToken = tNodeName;
			break;
		}

		m_nNodeStack = n;

		m_tNodeName = tNodeName;
		m_tNodeValue = Yogi::Core::TCharDescriptor<T>();
		m_pCurrentPosition = s;
		m_eNodeType = NODE_ELEMENT_END;

		bResult = true;

	} sequence;	// end sequence

	return bResult;
}



/*---------------------------------------------------------------------+\

 * ParseElementValueEnd -

\+---------------------------------------------------------------------*/
template < class T >
bool	TTokenizer<T>::ParseElementValueEnd
		(
		const Yogi::Core::TCharDescriptor<T>&	rName
		)
{
	bool	bResult = false;
	long	n;
	T*		s = m_pCurrentPosition;

	do	// sequence
	{
		s += SpanBlanks( s );


		if ( '<' != *s )
			break;
		++s;

		//s += SpanBlanks( s );

		if ( '/' != *s )
			break;
		++s;

		s += SpanBlanks( s );

		n = SpanName( s );
		if ( n < 1 )
			break;

		Yogi::Core::TCharDescriptor<T>	tNodeName( s, (size_t)n );
		s += n;

		s += SpanBlanks( s );

		if ( '>' != *s )
			break;
		++s;

		if ( tNodeName != rName )
			break;

		m_pCurrentPosition = s;

		bResult = true;

	} sequence;	// end sequence

	return bResult;
}


/*---------------------------------------------------------------------+\

 * ParseElementValue -

\+---------------------------------------------------------------------*/
template < class T >
bool	TTokenizer<T>::ParseElementValue
		(
		const Yogi::Core::TCharDescriptor<T>& rName
		)
{
	bool	bResult = false;
	bResult = ParseCData();
	if ( bResult )
	{
		bResult = ParseElementValueEnd( rName );
		return bResult;
	}

	bResult = ParseText();
	bResult = ParseElementValueEnd( rName );
	return bResult;
}


/*---------------------------------------------------------------------+\

 * ParseCData -

\+---------------------------------------------------------------------*/
template < class T >
bool	TTokenizer<T>::ParseCData
		(
		void
		)
{
	bool	bResult = false;
	T*		s = m_pCurrentPosition;
	T*		sEnd = m_pEndPosition;

	s += SpanBlanks( s );

	if ( Yogi::Core::TCharDescriptor<T>( s, 9 ) == "<![CDATA[" )
	{
		s += 9;
		T*	sData = s;

		while ( s < sEnd )
		{
			if ( ']' == *s )
			{
				if ( Yogi::Core::TCharDescriptor<T>( s, 3 ) == "]]>" )
				{
					m_tNodeValue = Yogi::Core::TCharDescriptor<T>( sData, (size_t)(s - sData) );
					m_pCurrentPosition = s + 3;
					m_eNodeType = NODE_CDATA;
					bResult = true;
					break;
				}
			}
			++s;
		}
	}
	return bResult;
}


/*---------------------------------------------------------------------+\

 * ParseText -

\+---------------------------------------------------------------------*/
template < class T >
bool	TTokenizer<T>::ParseText
		(
		void
		)
{
	bool	bResult = false;
	T*		s = m_pCurrentPosition;
	T*		sEnd = m_pEndPosition;

	s += SpanBlanks( s );

	T*		sBegin = s;
	while ( s < sEnd )
	{
		if ( '<' == *s )
		{
			if ( sBegin < s )
			{
				m_pCurrentPosition = s;
				m_eNodeType = NODE_TEXT;

				// strip trailing spaces
				while ( IsBlank( *(s-1) ) )
					--s;
				m_tNodeValue = Yogi::Core::TCharDescriptor<T>( sBegin, (size_t)(s - sBegin) );
				bResult = true;
			}
			break;
		}
		++s;
	}
	return bResult;
}


/*---------------------------------------------------------------------+\

 * ParseProcessingInstruction -

\+---------------------------------------------------------------------*/
template < class T >
bool	TTokenizer<T>::ParseProcessingInstruction
		(
		void
		)
{
	bool	bResult = false;
	long	n;
	T*		s = m_pCurrentPosition;
	T*		sEnd = m_pEndPosition;

	do	// sequence
	{
		if ( '<' != *s )
			break;
		++s;

		if ( '?' != *s )
			break;
		++s;

		s += SpanBlanks( s );

		n = SpanName( s );
		if ( n < 1 )
			break;

		Yogi::Core::TCharDescriptor<T>	tName( s, (size_t)n );
		s += n;

		s += SpanBlanks( s );

		T*	pValue = s;

		while ( s < sEnd )
		{
			if ( '?' == *s  &&  '>' == *(s+1) )
			{
				m_tNodeName = tName;
				m_tNodeValue = Yogi::Core::TCharDescriptor<T>( pValue, (size_t)(s - pValue) );
				s += 2;
				m_pCurrentPosition = s;
				m_eNodeType = NODE_PROCESSING_INSTRUCTION;
				bResult = true;
				break;
			}
			++s;
		}


	} sequence;	// end sequence

	return bResult;
}


/*---------------------------------------------------------------------+\

 * ParseComment -

\+---------------------------------------------------------------------*/
template < class T >
bool	TTokenizer<T>::ParseComment
		(
		void
		)
{
	bool	bResult = false;
	T*		s = m_pCurrentPosition;
	T*		sEnd = m_pEndPosition;

	if ( Yogi::Core::TCharDescriptor<T>( s, 4 ) == "<!--" )
	{
		// name will be "!--"
		m_tNodeName = Yogi::Core::TCharDescriptor<T>( s+1, 3 );

		s += 4;

		s += SpanBlanks( s );

		T*	sBegin = s;

		while ( s < sEnd )
		{
			if ( '-' == *s )
			{
				if ( Yogi::Core::TCharDescriptor<T>( s, 3 ) == "-->" )
				{
					m_tNodeValue = Yogi::Core::TCharDescriptor<T>( sBegin, (size_t)(s - sBegin) );
					m_eNodeType = NODE_COMMENT;
					m_pCurrentPosition = s + 3;
					bResult = true;
					break;
				}
			}
			++s;
		}
	}
	return bResult;
}




/*---------------------------------------------------------------------+\

 * ParseNotation -

\+---------------------------------------------------------------------*/
template < class T >
bool	TTokenizer<T>::ParseNotation
		(
		void
		)
{
	bool	bResult = false;
	T*		s = m_pCurrentPosition;
	T*		sEnd = m_pEndPosition;

	if ( '<' == *s )
	{
		++s;
		s += SpanBlanks( s );
		if ( '!' == *s  &&  '-' != *(s+1) )
		{
			long	nNest = 0;
			long	n;
			++s;
			s += SpanBlanks( s );
			n = SpanName( s );
			Yogi::Core::TCharDescriptor<T>	tName( s, (size_t)n );
			s += n;

			s += SpanBlanks( s );

			T*	sValue = s;

			while ( s < sEnd )
			{
				if ( nNest < 1 )
				{
					if ( '>' == *s )
					{
						m_tNodeName = tName;
						m_tNodeValue = Yogi::Core::TCharDescriptor<T>( sValue, (size_t)(s - sValue) );
						++s;
						m_pCurrentPosition = s;
						m_eNodeType = NODE_NOTATION;
						//m_bInsideElement = false;
						bResult = true;
						break;
					}
					else if ( '<' == *s )
					{
						++nNest;
					}
				}
				else
				{
					if ( '>' == *s )
						--nNest;
				}
				++s;
			}
		}
	}
	return bResult;
}





//-------------- Overridden Functions -----------------



/*---------------------------------------------------------------------+\

 * HeaderRequired -

\+---------------------------------------------------------------------*/
template< class T >
bool	TTokenizer<T>::HeaderRequired
		(
		bool	bRequired
		)
{
	bool	b = m_bHeaderRequired;
	m_bHeaderRequired = bRequired;
	return b;
}


/*---------------------------------------------------------------------+\

 * ProcessCallBack -

\+---------------------------------------------------------------------*/
template < class T >
bool	TTokenizer<T>::ProcessCallBack
		(
		XMLLite::VReadCallBack*	pCallBack
		)
{
	bool	bResult = false;
	if ( pCallBack )
	{
		Reset();
		m_pReadCallBack = pCallBack;
		bResult = ReadFromCallBack();
	}
	return bResult;
}




/*---------------------------------------------------------------------+\

 * Read -

\+---------------------------------------------------------------------*/
template < class T >
bool	TTokenizer<T>::Read
		(
		void
		)
{
	T*	s = m_pCurrentPosition;
	s += SpanBlanks( s );
	if ( s < m_pEndPosition )
	{
		return ParseNode();
	}
	else
	{
		return false;
	}
}


/*---------------------------------------------------------------------+\

 * Error -

\+---------------------------------------------------------------------*/
template < class T >
void	TTokenizer<T>::Error
		(
		const char* s
		)
{
	if ( 0 == m_nErrorLine )
	{
		size_t	n = ::strlen( s );
		m_sErrorString.AdjustUsed( n + 1 );
		strcpy_s( m_sErrorString.PointArray(),
					n + 1,
					s );

		// calculate the line number
		const T*	p = m_tFullStream.Pointer();
		const T*	pEnd = p + m_tFullStream.Length();
		const T*	pTarget = m_tNodeName.Pointer();
		n = 1;
		while ( p < pEnd )
		{
			if ( pTarget <= p )
				break;
			if ( '\r' == *p  &&  '\n' == *(p+1) )
			{
				++n;
				++p;
			}
			else if ( '\n' == *p  ||  '\r' == *p )
			{
				++n;
			}
			++p;
		}

		m_nErrorLine = (index_t)n;
		m_tErrorToken = m_tNodeName;

#ifdef _DEBUG
		Yogi::Core::DbgPrint( "Error in XML: %s\n", s );
		Yogi::Core::DbgPrint( "-- Line # %ld\n", m_nErrorLine );
		char	sTemp[128];
		m_tErrorToken.CopyTo( sTemp, sizeof(sTemp) );
		Yogi::Core::DbgPrint( "-- Token: %s\n", sTemp );
#endif


		// force us to get out.
		m_pCurrentPosition = m_pEndPosition;
		m_nNodeStack = 0;
	}
}


/*---------------------------------------------------------------------+\

 * ErrorLineNumber -

\+---------------------------------------------------------------------*/
template < class T >
index_t	TTokenizer<T>::ErrorLineNumber
		(
		void
		)
{
	return m_nErrorLine;
}



/*---------------------------------------------------------------------+\

 * ErrorString -

\+---------------------------------------------------------------------*/
template < class T >
Yogi::Core::TCharDescriptor<char>
		TTokenizer<T>::ErrorString
		(
		void
		)
{
	if ( 0 < m_nErrorLine )
	{
		char*	s = m_sErrorString.PointArray();
		return Yogi::Core::TCharDescriptor<char>( s, ::strlen(s) );
	}
	else
	{
		return Yogi::Core::TCharDescriptor<char>();
	}
}


/*---------------------------------------------------------------------+\

 * ErrorToken -

\+---------------------------------------------------------------------*/
template < class T >
Yogi::Core::TCharDescriptor<T>
		TTokenizer<T>::ErrorToken
		(
		void
		)
{
	return m_tErrorToken;
}


/*---------------------------------------------------------------------+\

 * ErrorStreamName -

\+---------------------------------------------------------------------*/
template < class T >
Yogi::Core::TCharDescriptor<char>
		TTokenizer<T>::ErrorStreamName
		(
		void
		)
{
	char*	s = m_sStreamName.PointArray();
	size_t	n = ::strlen( s );
	Yogi::Core::TCharDescriptor<char>	tName( s, n );
	return tName;
}



/*---------------------------------------------------------------------+\

 * NestDepth -

\+---------------------------------------------------------------------*/
template < class T >
int		TTokenizer<T>::NestDepth
		(
		void
		)
{
	return m_nNodeStack;
}


/*---------------------------------------------------------------------+\

 * NodeType -

\+---------------------------------------------------------------------*/
template < class T >
ENODETYPE
		TTokenizer<T>::NodeType
		(
		void
		)
{
	return m_eNodeType;
}


/*---------------------------------------------------------------------+\

 * NodeName -

\+---------------------------------------------------------------------*/
template < class T >
Yogi::Core::TCharDescriptor<T>
		TTokenizer<T>::NodeName
		(
		void
		)
{
	return m_tNodeName;
}


/*---------------------------------------------------------------------+\

 * NodeEmpty -

\+---------------------------------------------------------------------*/
template < class T >
bool	TTokenizer<T>::NodeEmpty
		(
		void
		)
{
	bool	bResult = false;

	switch ( m_eNodeType )
	{
	case NODE_NONE:		// starting state
		bResult = true;
		break;

	case NODE_ELEMENT:		// empty element "<tagname/>" or "<tagname>text</tagname>"
		if ( m_tNodeValue.Length() < 1 )
			bResult = true;
		break;
	case NODE_ELEMENT_BEGIN:	// begining element "<tagname>"
		bResult = false;
		break;
	case NODE_ELEMENT_END:	// ending element "</tagname>"
		bResult = true;
		break;

	case NODE_TEXT:
	case NODE_CDATA:
		bResult = false;
		break;

	case NODE_COMMENT:
		bResult = true;
		break;

	case NODE_HEADER:		// <?xml ...?>
	//NODE_ENTITY,
	case NODE_PROCESSING_INSTRUCTION:
	//NODE_DOCTYPE,
	case NODE_NOTATION:

	case NODE_UNKNOWN:		// other
	case NODE_BLANKS:			// spaces between nodes (currently never returned)
		bResult = true;
		break;
	}
	return bResult;
}


/*---------------------------------------------------------------------+\

 * NodeValue -

\+---------------------------------------------------------------------*/
template < class T >
Yogi::Core::TCharDescriptor<T>
		TTokenizer<T>::NodeValue
		(
		void
		)
{
	return m_tNodeValue;
}

/*---------------------------------------------------------------------+\

 * NodeValueAsInt -

\+---------------------------------------------------------------------*/
template < class T >
long	TTokenizer<T>::NodeValueAsInt
		(
		void
		)
{
	Yogi::Core::TCharDescriptor<T>	cd = NodeValue();
	if ( 0 < cd.Length() )
	{
		return NumberFromDec( cd.Pointer(), cd.Length() );
	}
	else
	{
		return 0;
	}
}


/*---------------------------------------------------------------------+\

 * NodeValueAsFloat -

\+---------------------------------------------------------------------*/
template < class T >
GFLOAT
		TTokenizer<T>::NodeValueAsFloat
		(
		void
		)
{
	Yogi::Core::TCharDescriptor<T>	cd = NodeValue();
	if ( 0 < cd.Length() )
	{
		return NumberFromFlt( cd.Pointer(), cd.Length() );
	}
	else
	{
		return 0;
	}
}



/*---------------------------------------------------------------------+\

 * AttributeCount -

\+---------------------------------------------------------------------*/
template < class T >
int		TTokenizer<T>::AttributeCount
		(
		void
		)
{
	return int(m_aAttributes.Length());
}


/*---------------------------------------------------------------------+\

 * AttributeName -

\+---------------------------------------------------------------------*/
template < class T >
Yogi::Core::TCharDescriptor<T>
		TTokenizer<T>::AttributeName
		(
		int	idx
		)
{
	AttributeInfo*	p = m_aAttributes.PointArray( idx );
	if ( p )
		return p->tName;
	else
		return Yogi::Core::TCharDescriptor<T>();
}


/*---------------------------------------------------------------------+\

 * AttributeValue -

\+---------------------------------------------------------------------*/
template < class T >
Yogi::Core::TCharDescriptor<T>
		TTokenizer<T>::AttributeValue
		(
		int	idx
		)
{
	AttributeInfo*	p = m_aAttributes.PointArray( idx );
	if ( p )
		return p->tValue;
	else
		return Yogi::Core::TCharDescriptor<T>();
}


/*---------------------------------------------------------------------+\

 * AttributeValue -

\+---------------------------------------------------------------------*/
template < class T >
Yogi::Core::TCharDescriptor<T>
		TTokenizer<T>::AttributeValue
		(
		const T*	sName
		)
{
	AttributeInfo*	p = m_aAttributes.PointArray();
	if ( p )
	{
		AttributeInfo*	pEnd = p + m_aAttributes.Length();
		while ( p < pEnd )
		{
			if ( p->tName == sName )
			{
				return p->tValue;
			}
			++p;
		}
	}
	return Yogi::Core::TCharDescriptor<T>();

}



/*---------------------------------------------------------------------+\

 * AttributeValueAsInt -

\+---------------------------------------------------------------------*/
template < class T >
long	TTokenizer<T>::AttributeValueAsInt
		(
		int idx
		)
{
	Yogi::Core::TCharDescriptor<T>	cd = AttributeValue( idx );
	if ( 0 < cd.Length() )
	{
		return NumberFromDec( cd.Pointer(), cd.Length() );
	}
	else
	{
		return 0;
	}
}

/*---------------------------------------------------------------------+\

 * AttributeValueAsInt -

\+---------------------------------------------------------------------*/
template < class T >
long	TTokenizer<T>::AttributeValueAsInt
		(
		const char*	sName
		)
{
	Yogi::Core::TCharDescriptor<T>	cd = AttributeValue( sName );
	if ( 0 < cd.Length() )
	{
		return NumberFromDec( cd.Pointer(), cd.Length() );
	}
	else
	{
		return 0;
	}
}


/*---------------------------------------------------------------------+\

 * AttributeValueAsFloat -

\+---------------------------------------------------------------------*/
template < class T >
GFLOAT
		TTokenizer<T>::AttributeValueAsFloat
		(
		int idx
		)
{
	Yogi::Core::TCharDescriptor<T>	cd = AttributeValue( idx );
	if ( 0 < cd.Length() )
	{
		return NumberFromFlt( cd.Pointer(), cd.Length() );
	}
	else
	{
		return 0;
	}
}


/*---------------------------------------------------------------------+\

 * AttributeValueAsFloat -

\+---------------------------------------------------------------------*/
template < class T >
GFLOAT
		TTokenizer<T>::AttributeValueAsFloat
		(
		const char*	sName
		)
{
	Yogi::Core::TCharDescriptor<T>	cd = AttributeValue( sName );
	if ( 0 < cd.Length() )
	{
		return NumberFromFlt( cd.Pointer(), cd.Length() );
	}
	else
	{
		return 0;
	}
}











}}




#endif /* _H_XMLLiteImpl */
